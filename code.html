<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOUR EATS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&family=Helvetica+Neue&display=swap" rel="stylesheet">
    <style>
        /* --- General & Base Styles (Adapted from no_one_help_official_website_25.html) --- */
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #f0c419; /* Golden yellow */
            --primary-gradient: linear-gradient(135deg, #c5a22d, #f0c419, #ffec8a);
            --text-color: #e0e0e0;
            --text-secondary-color: #a0a0a0;
            --font-main: 'Noto Sans TC', 'Helvetica Neue', sans-serif;
            --border-radius: 12px;
            --shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.7;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 30px 20px;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        .container {
            text-align: center;
            background-color: var(--surface-color);
            padding: 40px 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            max-width: 800px; /* Wider for AI results */
            width: 100%;
            border: 1px solid rgba(255,255,255,0.1);
        }
        h1 {
            font-size: 2.8em;
            font-weight: 700;
            margin-top: 0;
            margin-bottom: 20px;
            letter-spacing: 1px;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }
        h3, h4 {
            color: var(--primary-color);
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.5em;
            font-weight: 500;
            border-bottom: 2px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }
        p#result {
            color: var(--text-color);
            font-size: 1.1em;
            min-height: 25px;
            margin-bottom: 25px;
        }
        .divider {
            border-top: 1px solid rgba(255,255,255,0.1);
            margin: 30px 0;
        }

        /* --- Input & Buttons (Adapted from code (3).html & no_one_help_official_website_25.html) --- */
        input[type="file"] {
            display: block;
            margin: 20px auto;
            width: 100%;
            max-width: 400px;
            padding: 10px;
            color: var(--text-color);
            background-color: var(--surface-color);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
        }
        input[type="file"]::file-selector-button {
            background: var(--primary-gradient);
            color: #121212;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-right: 15px;
        }
        input[type="file"]::file-selector-button:hover {
            transform: translateY(-1px);
        }

        #image-preview-container { margin-top: 20px; text-align: center; background-color: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px;}
        #image-preview { max-width: 100%; max-height: 300px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: block; margin: 0 auto;}

        #preferences-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin-top: 15px;}
        .pref-item label {
            display: flex;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
            font-size: 1em;
            background-color: rgba(255,255,255,0.08);
            padding: 10px 15px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }
        .pref-item label:hover {
            background-color: rgba(255,255,255,0.15);
        }
        .pref-item input[type="checkbox"] {
            margin-right: 10px;
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary-color);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            outline: none;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .pref-item input[type="checkbox"]:checked {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        .pref-item input[type="checkbox"]:checked::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #121212;
            font-size: 14px;
            font-weight: bold;
        }

        #custom-pref-container { display: flex; gap: 10px; margin-top: 15px; }
        #custom-pref-input {
            flex-grow: 1;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            font-size: 1em;
            background-color: rgba(0,0,0,0.2);
            color: var(--text-color);
        }
        #custom-pref-input::placeholder { color: var(--text-secondary-color); }
        #add-pref-btn {
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            box-shadow: 0 4px 10px rgba(46, 204, 113, 0.3);
        }
        #add-pref-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 15px rgba(46, 204, 113, 0.4); }

        #custom-prefs-display { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 8px; }
        .custom-tag {
            background-color: rgba(255,255,255,0.1);
            color: var(--text-color);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            display: inline-flex;
            align-items: center;
            border: 1px solid rgba(255,255,255,0.15);
        }
        .delete-tag-btn {
            background: none;
            border: none;
            color: var(--text-secondary-color);
            margin-left: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            line-height: 1;
            transition: color 0.2s ease;
        }
        .delete-tag-btn:hover { color: var(--primary-color); }
        
        #language-selector {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            background-color: rgba(0,0,0,0.2);
            color: var(--text-color);
            margin-top: 15px;
            font-size: 1em;
            appearance: none;
            -webkit-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23e0e0e0" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 20px;
        }
        #language-selector option {
            background-color: var(--surface-color);
            color: var(--text-color);
        }

        .process-button {
            background: var(--primary-gradient);
            color: #121212;
            border: none;
            padding: 15px 25px;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            width: 100%;
            margin-top: 40px;
            box-shadow: 0 4px 10px rgba(240, 196, 25, 0.3);
        }
        .process-button:hover { transform: translateY(-3px); box-shadow: 0 6px 15px rgba(240, 196, 25, 0.4); }
        .process-button:disabled {
            background-color: #bdc3c7;
            background: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            color: #555;
        }

        /* --- AI Results Section (Adapted from code (3).html) --- */
        .result-section {
            background-color: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 15px 20px;
            margin-top: 20px;
            text-align: left;
        }
        .result-section h4 {
            margin-top: 0;
            color: var(--primary-color);
            font-size: 1.2em;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
        }
        .result-section ul { list-style-type: none; padding: 0; margin: 0; }
        .result-section li {
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex; /* For alignment */
            flex-direction: column;
        }
        .result-section li:last-child { border-bottom: none; }
        .dish-translation { display: flex; flex-direction: column; flex-grow: 1; }
        .original-text { font-size: 0.8em; color: var(--text-secondary-color); margin-top: 4px; }
        .original-text.filtered-out { color: #888 !important; }
        .highlight { font-weight: 500; color: #fff;}
        .filtered-out { color: #aaa; text-decoration: line-through; }
        .reason-tag {
            display: inline-block;
            margin-top: 8px;
            background-color: rgba(255, 193, 7, 0.15); /* light orange/yellow */
            color: var(--primary-color);
            font-size: 0.75em;
            font-weight: 500;
            padding: 4px 10px;
            border-radius: 10px;
            white-space: normal;
            border: 1px solid rgba(255, 193, 7, 0.25);
        }

        #status-container { display: flex; justify-content: center; align-items: center; flex-direction: column; padding: 20px; }
        .loader { border: 6px solid rgba(255,255,255,0.1); border-radius: 50%; border-top: 6px solid var(--primary-color); width: 50px; height: 50px; animation: spin 1.5s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .status-text { font-style: italic; color: var(--text-secondary-color); }

        /* --- Spinner (from åˆæ­¥æ­£å¸¸.html) --- */
        .spinner-section {
            display: none; /* Hidden until analysis is done */
            margin-top: 40px;
            padding-top: 30px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .wheel-container { position: relative; width: 300px; height: 300px; margin: 0 auto 30px; }
        canvas#wheel {
            width: 100%;
            height: 100%;
            transition: transform 5s cubic-bezier(0.1, 0.7, 0.3, 1);
            border-radius: 50%;
            background-color: #333; /* Fallback */
            cursor: pointer; /* Indicate it's interactive */
        }
        .pointer {
            position: absolute;
            top: -10px; /* Adjusted slightly higher */
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent; /* Larger pointer */
            border-right: 15px solid transparent;
            border-top: 30px solid var(--primary-color); /* Matches primary color */
            z-index: 10;
        }

        .spin-button {
            background: var(--primary-gradient);
            color: #121212;
            border: none;
            padding: 15px 45px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 40px;
            box-shadow: 0 4px 10px rgba(240, 196, 25, 0.3);
        }
        .spin-button:hover { background-color: #d35400; transform: translateY(-3px); box-shadow: 0 6px 15px rgba(240, 196, 25, 0.4); }
        .spin-button:disabled { background-color: #bdc3c7; background: #888; cursor: not-allowed; transform: none; box-shadow: none; color: #555;}
        
        .action-btn-group { display: flex; justify-content: center; gap: 15px; margin-top: 20px;}
        .action-btn {
            background-color: var(--primary-color);
            color: #121212;
            border: none;
            padding: 12px 25px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .action-btn.secondary {
            background-color: rgba(255,255,255,0.1);
            color: var(--text-color);
        }
        .action-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .action-btn.secondary:hover { background-color: rgba(255,255,255,0.2); }

        /* --- History Section (from åˆæ­¥æ­£å¸¸.html) --- */
        .history-section {
            display: none;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        #history-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Card layout */
        }
        #history-list li {
            background-color: rgba(0,0,0,0.2);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            overflow: hidden;
            text-align: left;
            border: 1px solid rgba(255,255,255,0.1);
            position: relative; /* For the action buttons */
        }
        .history-img {
            width: 100%;
            height: 180px; /* Slightly smaller height */
            object-fit: cover;
            background-color: rgba(255,255,255,0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-secondary-color);
            font-size: 0.9em;
        }
        .history-img img { width: 100%; height: 100%; object-fit: cover; }
        .history-details { padding: 15px; }
        .history-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px; }
        .history-header h4 { margin: 0; color: #fff; font-size: 1.1em; border-bottom: none; padding-bottom: 0;}
        .history-actions button {
            background: none;
            border: none;
            font-size: 1em;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s, color 0.2s;
            color: var(--text-secondary-color);
        }
        .history-actions button:hover { opacity: 1; color: var(--primary-color); }
        .history-details p { margin: 0 0 12px 0; font-size: 0.95em; color: var(--text-color); white-space: pre-wrap; word-break: break-word; }
        .timestamp { font-size: 0.8em; color: var(--text-secondary-color); text-align: right; display: block; }
        .clear-history-container { margin-top: 25px; text-align: center; }
        #clear-history-btn {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 4px 10px rgba(231, 76, 60, 0.3);
        }
        #clear-history-btn:hover { background-color: #c0392b; transform: translateY(-2px); box-shadow: 0 6px 15px rgba(231, 76, 60, 0.4); }

        /* --- Modal (from åˆæ­¥æ­£å¸¸.html) --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .modal {
            background: var(--surface-color);
            padding: 25px;
            border-radius: var(--border-radius);
            width: 100%;
            max-width: 400px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            text-align: left;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .modal h2 {
            margin-top: 0;
            margin-bottom: 20px;
            color: var(--primary-color);
            font-size: 1.5em;
            text-align: center;
            -webkit-background-clip: unset; /* Override text gradient */
            -webkit-text-fill-color: unset; /* Override text gradient */
        }
        .modal-image-preview {
            width: 100%;
            height: 180px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border: 1px dashed rgba(255,255,255,0.1);
        }
        .modal-image-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .modal-image-preview span { color: var(--text-secondary-color); }
        .modal #modal-image-input { display: none; }
        .modal .upload-btn-label {
            display: block;
            width: 100%;
            text-align: center;
            padding: 10px;
            background: #3498db;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 15px;
            transition: background 0.3s;
            box-sizing: border-box;
            font-weight: bold;
        }
        .modal .upload-btn-label:hover { background: #2980b9; }
        .modal textarea {
            width: 100%;
            height: 80px;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            font-size: 1em;
            resize: vertical;
            box-sizing: border-box;
            margin-bottom: 20px;
            background-color: rgba(0,0,0,0.2);
            color: var(--text-color);
        }
        .modal textarea::placeholder { color: var(--text-secondary-color); }
        .modal-actions { display: flex; justify-content: space-between; gap: 10px; }
        .modal-actions button {
            flex-grow: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
            color: #121212; /* Default for buttons in modal */
        }
        #modal-save-btn { background: #2ecc71; }
        #modal-save-btn:hover { background: #27ae60; }
        #modal-cancel-btn { background: #bdc3c7; color: #121212;}
        #modal-cancel-btn:hover { background: #95a5a6; }

        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) {
            body { padding: 20px 15px; }
            .container { padding: 30px 20px; }
            h1 { font-size: 2.2em; }
            h3, h4 { font-size: 1.3em; }
            .wheel-container { width: 250px; height: 250px; }
            .spin-button { padding: 12px 30px; font-size: 1em; }
            .action-btn { padding: 10px 20px; font-size: 0.9em; }
            #history-list { grid-template-columns: 1fr; }
            .add-option input { max-width: 100%; }
            #preferences-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>TOUR EATS</h1>
        <p id="result">ä¸Šå‚³èœå–®åœ–ç‰‡ï¼Œè¨­å®šåå¥½ï¼Œè®“ AI å¹«æ‚¨åˆ†æï¼</p>

        <div class="main-content-section" id="initial-setup-section">
            <h3>1. ä¸Šå‚³èœå–®åœ–ç‰‡</h3>
            <input type="file" id="menu-image" accept="image/*">
            <div id="image-preview-container"><img id="image-preview" src="https://i.imgur.com/wSAa8a1.jpeg" alt="Menu Preview"></div>
            
            <div class="divider"></div>
            <h3>2. è¨­å®šæ‚¨çš„é£²é£Ÿåå¥½</h3>
            <div id="preferences-grid">
                <div class="pref-item"><label><input type="checkbox" id="pref-vegetarian"> æˆ‘æ˜¯ç´ é£Ÿè€…</label></div>
                <div class="pref-item"><label><input type="checkbox" id="pref-no-pork"> ä¸è¦è±¬è‚‰</label></div>
                <div class="pref-item"><label><input type="checkbox" id="pref-no-nuts"> ä¸è¦å …æœ/èŠ±ç”Ÿ</label></div>
                <div class="pref-item"><label><input type="checkbox" id="pref-no-alcohol"> ä¸è¦é…’ç²¾</label></div>
                <div class="pref-item"><label><input type="checkbox" id="pref-no-spicy"> ä¸åƒè¾£</label></div>
            </div>
            <h4 style="margin-top:20px; margin-bottom: 5px; text-align: center;">è‡ªè¨‚ä¸æƒ³åƒçš„é£Ÿæ (ä¾‹å¦‚: é›è‚‰)</h4>
            <div id="custom-pref-container">
                <input type="text" id="custom-pref-input" placeholder="è¼¸å…¥é—œéµå­—...">
                <button id="add-pref-btn">æ–°å¢</button>
            </div>
            <div id="custom-prefs-display"></div>
            
            <div class="divider"></div>
            <h3>3. é¸æ“‡ç¿»è­¯èªè¨€</h3>
            <select id="language-selector">
                <option value="zh-TW">ç¹é«”ä¸­æ–‡ (Traditional Chinese)</option>
                <option value="zh-CN">ç°¡é«”ä¸­æ–‡ (Simplified Chinese)</option>
                <option value="en">English</option>
                <option value="ja">æ—¥æœ¬èª (Japanese)</option>
                <option value="ko">í•œêµ­ì–´ (Korean)</option>
            </select>
            
            <button class="process-button" id="process-btn">é–‹å§‹åˆ†æèœå–®</button>
        </div>

        <div id="analysis-results-section" style="display: none;">
            <div class="divider"></div>
            <h3>4. AI åˆ†æçµæœ</h3>
            <div id="results"></div>
        </div>

        <div class="spinner-section" id="spinner-section">
            <div class="divider"></div>
            <h3>5. ç¾é£Ÿé¸æ“‡è½‰ç›¤</h3>
            <p id="spinner-result-text">é»æ“ŠæŒ‰éˆ•ï¼Œæ±ºå®šä½ çš„ä¸‹ä¸€é¤ï¼</p>
            <div class="wheel-container">
                <div class="pointer"></div>
                <canvas id="wheel" width="350" height="350"></canvas>
            </div>
            <button class="spin-button" id="spin-btn">é–‹å§‹æ—‹è½‰ï¼</button>
            <div class="action-btn-group" id="spin-actions" style="display: none;">
                <button class="action-btn" id="keep-btn">å°±æ˜¯å®ƒäº†ï¼</button>
                <button class="action-btn secondary" id="respin-btn">å†è½‰ä¸€æ¬¡</button>
            </div>
        </div>

        <div class="history-section" id="history-section">
            <div class="divider"></div>
            <h3>ç¾é£Ÿæ—¥èªŒ</h3>
            <div id="history-list"></div>
            <div class="clear-history-container"><button id="clear-history-btn">æ¸…é™¤å…¨éƒ¨ç´€éŒ„</button></div>
        </div>
    </div>

    <!-- è¨˜éŒ„/ç·¨è¼¯å½ˆå‡ºè¦–çª— HTML -->
    <div class="modal-overlay" id="log-modal-overlay">
        <div class="modal">
            <h2 id="modal-title"></h2>
            <div class="modal-image-preview" id="modal-image-preview"><span>åœ–ç‰‡é è¦½å€</span></div>
            <label for="modal-image-input" class="upload-btn-label">æ›´æ›ç…§ç‰‡</label>
            <input type="file" id="modal-image-input" accept="image/*">
            <textarea id="modal-text-input" placeholder="åœ¨é€™è£¡å¯«ä¸‹ä½ çš„ç”¨é¤å¿ƒå¾—..."></textarea>
            <div class="modal-actions">
                <button id="modal-cancel-btn"></button>
                <button id="modal-save-btn"></button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // =====ã€æ‚¨çš„ Azure è³‡è¨Šã€‘=====
            const AZURE_VISION_KEY = '2eIQpQlLKEaHUo6oPEOZ1Rc4OAcfgxwSQ1IGLPLMYxWxNavbuNxGJQQJ99BGACqBBLyXJ3w3AAAAACOG6FFo';
            const AZURE_VISION_ENDPOINT = 'https://myhackathon-cv-service.services.ai.azure.com/';
            const AZURE_TRANSLATOR_KEY = '4kHZNgnsEFrUxfkSAEkflaDgEOF4dDk9NI2EjDq8k6kcnYeqHiY2JQQJ99BGACqBBLyXJ3w3AAAAACOGrcjp';
            const AZURE_TRANSLATOR_REGION = 'southeastasia';
            const AZURE_OPENAI_ENDPOINT = 'https://menu.openai.azure.com/';
            const AZURE_OPENAI_KEY = '6VpbFBGvvQkGXqnIqBu3AvoqYnqyenQUS2TIUzg2LyqVS5eMln9yJQQJ99BGACYeBjFXJ3w3AAABACOG1nCR';
            const AZURE_OPENAI_DEPLOYMENT_NAME = 'my-menu-gpt';

            // --- DOM Elements ---
            const imageInput = document.getElementById('menu-image');
            const imagePreview = document.getElementById('image-preview');
            const processBtn = document.getElementById('process-btn');
            const resultsDiv = document.getElementById('results');
            const analysisResultsSection = document.getElementById('analysis-results-section');
            const customPrefInput = document.getElementById('custom-pref-input');
            const addPrefBtn = document.getElementById('add-pref-btn');
            const customPrefsDisplay = document.getElementById('custom-prefs-display');
            const languageSelector = document.getElementById('language-selector');

            // Spinner DOM
            const spinnerSection = document.getElementById('spinner-section');
            const wheel = document.getElementById('wheel');
            const spinBtn = document.getElementById('spin-btn');
            const spinnerResultText = document.getElementById('spinner-result-text');
            const spinActions = document.getElementById('spin-actions');
            const keepBtn = document.getElementById('keep-btn');
            const respinBtn = document.getElementById('respin-btn');
            const ctx = wheel.getContext('2d');

            // History DOM
            const historySection = document.getElementById('history-section');
            const historyList = document.getElementById('history-list');
            const clearHistoryBtn = document.getElementById('clear-history-btn');

            // Modal DOM
            const modalOverlay = document.getElementById('log-modal-overlay');
            const modalTitle = document.getElementById('modal-title');
            const modalImagePreview = document.getElementById('modal-image-preview');
            const modalImageInput = document.getElementById('modal-image-input');
            const modalTextInput = document.getElementById('modal-text-input');
            const modalSaveBtn = document.getElementById('modal-save-btn');
            const modalCancelBtn = document.getElementById('modal-cancel-btn');

            // --- Variables ---
            let customPreferences = [];
            let currentRotation = 0;
            let isSpinning = false;
            let history = [];
            let editingIndex = null;
            let currentLogEntry = {};
            let hoveredSliceIndex = null;

            // AI results storage
            let allAnalyzedDishes = [];
            let recommendedDishes = [];
            let spinnerOptions = [];
            const spinnerColors = ['#34495e', '#f39c12', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#1abc9c', '#e67e22', '#a0a0a0', '#c0392b', '#7f8c8d', '#d35400'];

            // --- Utility Functions ---
            const updateStatus = (message, showLoader) => {
                let loaderHtml = showLoader ? '<div class="loader"></div>' : '';
                resultsDiv.innerHTML = `<div id="status-container">${loaderHtml}<div class="status-text">${message}</div></div>`;
                analysisResultsSection.style.display = 'block';
                spinnerSection.style.display = 'none';
            };

            const resizeImage = (file, maxWidth, maxHeight, quality) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = event => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let { width, height } = img;
                        if (width > height) {
                            if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; }
                        } else {
                            if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; }
                        }
                        canvas.width = width;
                        canvas.height = height;
                        canvas.getContext('2d').drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', quality));
                    };
                };
                reader.onerror = error => reject(error);
            });

            // --- AI & Filtering Logic ---
            async function getOcrText(imageSource) {
                updateStatus('æ­£åœ¨å°‡åœ–ç‰‡ä¸Šå‚³è‡³ Azure AI Vision (v3.2) é€²è¡Œåˆ†æ...', true);
                const cleanEndpoint = AZURE_VISION_ENDPOINT.replace(/\/+$/, "");
                const analyzeUrl = `${cleanEndpoint}/vision/v3.2/read/analyze`;
                let imageBody;
                if (typeof imageSource === 'string') {
                    const imageResponse = await fetch(imageSource);
                    imageBody = await imageResponse.blob();
                } else {
                    imageBody = imageSource;
                }
                const response = await fetch(analyzeUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/octet-stream', 'Ocp-Apim-Subscription-Key': AZURE_VISION_KEY },
                    body: imageBody
                });
                if (!response.ok) { 
                    const errorData = await response.json(); 
                    throw new Error(`Azure API éŒ¯èª¤ (æäº¤éšæ®µ): ${errorData.error.message}`); 
                }
                const operationLocation = response.headers.get('Operation-Location');
                if (!operationLocation) throw new Error('ç„¡æ³•å¾ Azure å›æ‡‰ä¸­ç²å–æ“ä½œä½ç½®ã€‚');
                let result;
                while (true) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    updateStatus('æ­£åœ¨å¾ Azure ç²å–è¾¨è­˜çµæœ...', true);
                    const resultResponse = await fetch(operationLocation, { headers: { 'Ocp-Apim-Subscription-Key': AZURE_VISION_KEY } });
                    result = await resultResponse.json();
                    if (result.status === 'succeeded') return result.analyzeResult.readResults.flatMap(page => page.lines.map(line => line.text)).join('\n');
                    if (result.status === 'failed') throw new Error(`Azure OCR è™•ç†å¤±æ•—: ${result.error?.message || 'æœªçŸ¥éŒ¯èª¤'}`);
                }
            }

            async function filterDishesWithAzureAI(rawText) {
                const apiEndpoint = `${AZURE_OPENAI_ENDPOINT}/openai/deployments/${AZURE_OPENAI_DEPLOYMENT_NAME}/chat/completions?api-version=2023-07-01-preview`;
                const systemPrompt = `ä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„èœå–®åˆ†æå¸«ã€‚æˆ‘æœƒæä¾›å¾èœå–®åœ–ç‰‡ OCR è¾¨è­˜å‡ºçš„æ–‡å­—ã€‚ä½ çš„ä»»å‹™æ˜¯ï¼š
1. åªæ‰¾å‡ºä»£è¡¨ã€Œèœå“åç¨±ã€æˆ–ã€Œé£²æ–™åç¨±ã€çš„é …ç›®ã€‚
2. å¿½ç•¥æ‰€æœ‰åˆ†é¡æ¨™é¡Œï¼ˆå¦‚ "ä¸»é£Ÿ", "é£²æ–™", "Appetizers"ï¼‰ã€åƒ¹æ ¼ã€åœ°å€ã€é›»è©±ã€æè¿°æ€§æ–‡å­—æˆ–ä»»ä½•éèœå“é …ç›®ã€‚
3. å°‡çµæœä»¥ä¸€å€‹ JSON é™£åˆ—çš„å½¢å¼å›å‚³ï¼Œé™£åˆ—ä¸­æ¯å€‹å…ƒç´ éƒ½æ˜¯ä¸€å€‹èœå“åç¨±å­—ä¸²ã€‚ä¾‹å¦‚: ["éº»å©†è±†è…", "è±šéª¨æ‹‰éºµ", "å¯å£å¯æ¨‚"]ã€‚
4. å¦‚æœæ‰¾ä¸åˆ°ä»»ä½•èœå“ï¼Œè«‹å›å‚³ä¸€å€‹ç©ºçš„ JSON é™£åˆ— []ã€‚
5. ä½ çš„å›å‚³å¿…é ˆæ˜¯åš´æ ¼çš„ JSON æ ¼å¼ï¼Œä¸”æ ¹ç‰©ä»¶è¦æœ‰ä¸€å€‹ key å«åš "dishes"ï¼Œå…¶ value æ˜¯èœå“åç¨±é™£åˆ—ã€‚ç¯„ä¾‹ï¼š { "dishes": ["èœå“A", "èœå“B"] }`;
                const userPrompt = `é€™æ˜¯å¾èœå–®è¾¨è­˜å‡ºçš„æ–‡å­—ï¼Œè«‹å¹«æˆ‘æ‰¾å‡ºæ‰€æœ‰èœå“å’Œé£²æ–™åç¨±ï¼š\n\n${rawText}`;
                const body = { messages: [ { role: "system", content: systemPrompt }, { role: "user", content: userPrompt } ] };

                const response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'api-key': AZURE_OPENAI_KEY },
                    body: JSON.stringify(body)
                });

                if (!response.ok) { throw new Error(`Azure OpenAI (èœå“è¾¨è­˜) API éŒ¯èª¤: ${response.statusText}`); }
                const data = await response.json();
                try {
                    const content = JSON.parse(data.choices[0].message.content);
                    const dishes = content.dishes || [];
                    if (!Array.isArray(dishes)) throw new Error("AI å›å‚³çš„æ ¼å¼ä¸æ˜¯æœ‰æ•ˆçš„é™£åˆ—ã€‚");
                    return dishes;
                } catch (e) {
                    console.error("è§£æ AI å›æ‡‰æ™‚å‡ºéŒ¯ (èœå“è¾¨è­˜):", data.choices[0].message.content);
                    throw new Error("ç„¡æ³•è§£æ AI å›å‚³çš„èœå“åˆ—è¡¨ã€‚");
                }
            }

            async function analyzeIngredientsWithAzureAI(dishes, customPrefs) {
                const apiEndpoint = `${AZURE_OPENAI_ENDPOINT}/openai/deployments/${AZURE_OPENAI_DEPLOYMENT_NAME}/chat/completions?api-version=2023-07-01-preview`;
                const systemPrompt = `ä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„é£Ÿå“ç§‘å­¸å®¶å’Œå»šå¸«ã€‚ä½ çš„ä»»å‹™æ˜¯åˆ†æèœå“ï¼Œä¸¦æ ¹æ“šä½¿ç”¨è€…çš„è‡ªè¨‚åå¥½é€²è¡Œèªæ„åˆ¤æ–·ã€‚
**ä½ çš„å›å‚³å¿…é ˆæ˜¯åš´æ ¼çš„ JSON æ ¼å¼ï¼ŒåŒ…å«ä»¥ä¸‹æ¬„ä½ï¼š**
1.  \`name\`: (string) èœå“çš„åŸå§‹åç¨±ã€‚
2.  \`englishName\`: (string) é€™é“èœæœ€æ¨™æº–çš„**è‹±æ–‡ç¿»è­¯åç¨±**ã€‚
3.  \`mainIngredients\`: (string array) é€™é“èœæœ€å¸¸è¦‹çš„**è‹±æ–‡**ä¸»è¦é£Ÿæåˆ—è¡¨ã€‚
4.  \`allergens\`: (string array) å¾é€™å€‹å›ºå®šåˆ—è¡¨ä¸­é¸æ“‡å¯èƒ½çš„éæ•åŸï¼šPork, Beef, Chicken, Fish, Seafood, Lamb, Nuts, Peanuts, Alcohol, Spicy, Dairy, Gluten, Eggsã€‚
5.  \`customFilterMatch\`: (string or null) æª¢æŸ¥èœå“æ˜¯å¦ç¬¦åˆä½¿ç”¨è€…çš„è‡ªè¨‚åå¥½ã€‚å¦‚æœç¬¦åˆï¼Œæ­¤æ¬„ä½æ‡‰ç‚º**è§£é‡‹åŸå› çš„è‹±æ–‡**ï¼ˆä¾‹å¦‚ï¼š"Contains chicken thigh, matching the 'chicken' filter"ï¼‰ï¼›å¦‚æœä¸ç¬¦åˆï¼Œæ­¤æ¬„ä½å¿…é ˆç‚º \`null\`ã€‚
**èªæ„åˆ¤æ–·è¦å‰‡ï¼š**
- ä½ å¿…é ˆã€Œèˆ‰ä¸€åä¸‰ã€ã€‚å¦‚æœä½¿ç”¨è€…çš„åå¥½æ˜¯ã€Œé›è‚‰ (chicken)ã€ï¼Œé‚£éº¼èœå“ä¸­çš„ã€Œé›è…¿ã€æˆ–ã€Œé›ç¿…ã€éƒ½ç®—ç¬¦åˆã€‚
- å¦‚æœä½¿ç”¨è€…çš„åå¥½æ˜¯ã€Œç‰›è‚‰ (beef)ã€ï¼Œé‚£éº¼ã€Œç‰›æ’ã€ã€ã€Œç‰›è…©ã€æˆ–ã€Œç‰›å°¾ã€éƒ½ç®—ç¬¦åˆã€‚
- å¦‚æœä½¿ç”¨è€…çš„è‡ªè¨‚åå¥½åˆ—è¡¨ç‚ºç©ºï¼Œå‰‡ \`customFilterMatch\` æ°¸é ç‚º \`null\`ã€‚`;
                
                const analysisPromises = dishes.map(dishName => {
                    const userPrompt = `ä½¿ç”¨è€…çš„è‡ªè¨‚æ’é™¤é …ç›®æ˜¯ï¼š[${customPrefs.join(', ')}]\n\nç¾åœ¨ï¼Œè«‹åˆ†æé€™é“èœå“: "${dishName}"`;
                    const body = { messages: [ { role: "system", content: systemPrompt }, { role: "user", content: userPrompt } ] };
                    
                    return fetch(apiEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'api-key': AZURE_OPENAI_KEY },
                        body: JSON.stringify(body)
                    }).then(response => {
                        if (!response.ok) { return { name: dishName, error: true, englishName: dishName, mainIngredients: [], allergens: [], customFilterMatch: null }; }
                        return response.json();
                    }).then(data => {
                        if (data.error) return data;
                        try {
                            const parsedContent = JSON.parse(data.choices[0].message.content);
                            return {
                                name: parsedContent.name || dishName,
                                englishName: parsedContent.englishName || dishName,
                                mainIngredients: parsedContent.mainIngredients || [],
                                allergens: parsedContent.allergens || [],
                                customFilterMatch: parsedContent.customFilterMatch || null,
                                error: false
                            };
                        } catch (e) { return { name: dishName, error: true, englishName: dishName, mainIngredients: ["Analysis failed"], allergens: [], customFilterMatch: null }; }
                    }).catch(err => { return { name: dishName, error: true, englishName: dishName, mainIngredients: ["Network error"], allergens: [], customFilterMatch: null }; });
                });
                return Promise.all(analysisPromises);
            }

            async function translateText(textArray, sourceLang, targetLang) {
                const endpoint = "https://api.cognitive.microsofttranslator.com";
                let url = `${endpoint}/translate?api-version=3.0&from=${sourceLang}&to=${targetLang}`;
                const textsToTranslate = [
                    ...textArray,
                    'ğŸ‘ Recommended Dishes', 'ğŸ‘ Filtered Dishes', 
                    'No recommended dishes found matching all your preferences.',
                    "Great! All dishes seem to match your preferences.",
                    'Contains meat', 'Contains pork', 'Contains nuts', 'Contains alcohol', 'Spicy', 'Analysis failed' // Common filter reasons
                ];
                const uniqueTexts = Array.from(new Set(textsToTranslate.filter(t => t && typeof t === 'string' && t.trim() !== '')));
                const body = uniqueTexts.map(text => ({ 'text': text }));
                if (body.length === 0) return {};
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Ocp-Apim-Subscription-Key': AZURE_TRANSLATOR_KEY, 'Ocp-Apim-Subscription-Region': AZURE_TRANSLATOR_REGION, 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                if (!response.ok) { const errorData = await response.json(); throw new Error(`Azure Translator API éŒ¯èª¤: ${errorData.error.message}`); }
                const data = await response.json();
                const translationMap = {};
                for (let i = 0; i < uniqueTexts.length; i++) {
                    translationMap[uniqueTexts[i]] = data[i].translations[0].text;
                }
                return translationMap;
            }
            
            function getFilterReasons(analyzedDish) {
                const isVegetarian = document.getElementById('pref-vegetarian').checked;
                const noPork = document.getElementById('pref-no-pork').checked;
                const noNuts = document.getElementById('pref-no-nuts').checked;
                const noAlcohol = document.getElementById('pref-no-alcohol').checked;
                const noSpicy = document.getElementById('pref-no-spicy').checked;
                if(analyzedDish.error){ return "Analysis failed"; }
                const lowerCaseAllergens = (analyzedDish.allergens || []).map(a => a.toLowerCase());
                let reason = '';
                const meatAllergens = ['pork', 'beef', 'chicken', 'lamb', 'fish', 'seafood'];
                if (isVegetarian && lowerCaseAllergens.some(a => meatAllergens.includes(a))) reason = 'Contains meat';
                else if (noPork && lowerCaseAllergens.includes('pork')) reason = 'Contains pork';
                else if (noNuts && (lowerCaseAllergens.includes('nuts') || lowerCaseAllergens.includes('peanuts'))) reason = 'Contains nuts';
                else if (noAlcohol && lowerCaseAllergens.includes('alcohol')) reason = 'Contains alcohol';
                else if (noSpicy && lowerCaseAllergens.includes('spicy')) reason = 'Spicy';
                else if (analyzedDish.customFilterMatch) reason = analyzedDish.customFilterMatch;
                return reason;
            }
            
            function generateFinalHtml(dishesWithReasons, translationMap) {
                let recommendedList = '';
                let filteredList = '';
                let recommendedCount = 0;
                let filteredCount = 0;
                dishesWithReasons.forEach((dish) => {
                    const filterReason = dish.filterReason;
                    const translatedName = translationMap[dish.englishName] || dish.englishName;
                    const translatedIngredients = translationMap[dish.mainIngredients.join(', ')] || dish.mainIngredients.join(', ');
                    const translatedReason = translationMap[filterReason] || filterReason;
                    const originalNameHtml = (translatedName.toLowerCase() !== dish.name.toLowerCase()) ? `<span class="original-text">${dish.name}</span>` : '';
                    const ingredientsHtml = `<span class="original-text">${dish.error ? (translationMap["Analysis failed"] || "åˆ†æå¤±æ•—") : translatedIngredients}</span>`;
                    if (filterReason) {
                        filteredCount++;
                        const reasonHtml = `<span class="reason-tag">âš ï¸ ${translatedReason}</span>`;
                        const itemHtml = `<div class="dish-translation"><span class="filtered-out">${translatedName}</span>${originalNameHtml}${ingredientsHtml}${reasonHtml}</div>`;
                        filteredList += `<li>${itemHtml}</li>`;
                    } else {
                        recommendedCount++;
                        const itemHtml = `<div class="dish-translation"><span class="highlight">${translatedName}</span>${originalNameHtml}${ingredientsHtml}</div>`;
                        recommendedList += `<li>${itemHtml}</li>`;
                    }
                });
                const translatedRecommendedTitle = translationMap['ğŸ‘ Recommended Dishes'] || 'ğŸ‘ æ¨è–¦èœè‰²';
                const translatedFilteredTitle = translationMap['ğŸ‘ Filtered Dishes'] || 'ğŸ‘ å·²éæ¿¾èœè‰²';
                const noRecFound = translationMap['No recommended dishes found matching all your preferences.'] || 'æ²’æœ‰æ‰¾åˆ°ç¬¦åˆæ‚¨æ‰€æœ‰åå¥½çš„æ¨è–¦èœè‰²ã€‚';
                const allMatch = translationMap["Great! All dishes seem to match your preferences."] || 'å¤ªæ£’äº†ï¼æ‰€æœ‰èœè‰²ä¼¼ä¹éƒ½ç¬¦åˆæ‚¨çš„åå¥½ã€‚';
                let finalHtml = `<div class="result-section"><h4>${translatedRecommendedTitle} (${recommendedCount})</h4><ul>${recommendedList || `<li>${noRecFound}</li>`}</ul></div>`;
                finalHtml += `<div class="result-section"><h4>${translatedFilteredTitle} (${filteredCount})</h4><ul>${filteredList || `<li>${allMatch}</li>`}</ul></div>`;
                return finalHtml;
            }

            // --- Spinner Logic (CORRECTED) ---
            const drawWheel = () => {
                const numOptions = spinnerOptions.length;
                const centerX = wheel.width / 2;
                const centerY = wheel.height / 2;
                const baseRadius = wheel.width / 2 - 10; 

                ctx.clearRect(0, 0, wheel.width, wheel.height);
                
                if (numOptions === 0) {
                    spinBtn.disabled = true;
                    if (analysisResultsSection.style.display !== 'none') {
                         spinnerResultText.textContent = 'æ²’æœ‰æ¨è–¦èœè‰²å¯ä¾›é¸æ“‡ã€‚';
                    } else {
                         spinnerResultText.textContent = 'è«‹å…ˆåˆ†æèœå–®ä»¥è¼‰å…¥é¸é …ã€‚';
                    }
                    spinActions.style.display = 'none';
                    return;
                }
                
                // ** THE FIX IS HERE **
                // Ensure spin button is enabled if there are options
                if (!isSpinning) {
                    spinBtn.disabled = false;
                }

                const arcSize = 2 * Math.PI / numOptions;
                
                spinnerOptions.forEach((option, i) => {
                    const isHighlighted = (i === hoveredSliceIndex);
                    const radius = isHighlighted ? baseRadius + 5 : baseRadius;
                    const angle = i * arcSize - Math.PI / 2;

                    ctx.save();
                    ctx.fillStyle = spinnerColors[i % spinnerColors.length];
                    if (isHighlighted) {
                        ctx.shadowColor = '#f0c419';
                        ctx.shadowBlur = 20;
                    }
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, angle, angle + arcSize);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();

                    ctx.save();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, angle, angle + arcSize);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();

                    if (isHighlighted) {
                        ctx.save();
                        ctx.fillStyle = '#fff';
                        ctx.font = `bold 16px ${getComputedStyle(document.body).fontFamily.split(',')[0]}, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const textAngle = angle + arcSize / 2;
                        ctx.translate(centerX + Math.cos(textAngle) * radius * 0.65, centerY + Math.sin(textAngle) * radius * 0.65);
                        ctx.rotate(textAngle + Math.PI / 2);
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                        ctx.shadowBlur = 5;
                        const maxWidth = radius * 1.1;
                        ctx.fillText(option, 0, 0, maxWidth);
                        ctx.restore();
                    }
                });
            };

            const spin = () => {
                if (isSpinning || spinnerOptions.length === 0) return;
                isSpinning = true;
                spinBtn.disabled = true;
                spinnerResultText.textContent = 'è½‰å•Šè½‰...';
                spinActions.style.display = 'none';
                hoveredSliceIndex = null;
                drawWheel(); 

                const randomSpins = Math.floor(Math.random() * 5) + 5;
                const randomStopAngle = Math.random() * 360;
                const totalRotation = randomSpins * 360 + randomStopAngle;
                const newRotation = currentRotation + totalRotation;

                wheel.style.transition = 'transform 5s cubic-bezier(0.1, 0.7, 0.3, 1)';
                wheel.style.transform = `rotate(${newRotation}deg)`;
                currentRotation = newRotation;

                setTimeout(() => {
                    isSpinning = false;
                    spinBtn.disabled = false;
                    
                    // Simplified and corrected winner calculation
                    const finalAngle = currentRotation % 360;
                    const winningAngle = (360 - finalAngle) % 360; 
                    const arcSizeDeg = 360 / spinnerOptions.length;
                    const winnerIndex = Math.floor(winningAngle / arcSizeDeg);
                    const winnerDishName = spinnerOptions[winnerIndex];

                    if (winnerDishName) {
                        spinnerResultText.textContent = `æ­å–œï¼ä»Šå¤©çš„é¸æ“‡æ˜¯ï¼š${winnerDishName}`;
                        const dishFullDetails = recommendedDishes.find(d => 
                            (languageSelector.value === 'en' ? d.englishName : (finalTranslationMap[d.englishName] || d.englishName)) === winnerDishName
                        );
                        currentLogEntry = { text: winnerDishName, fullDetails: dishFullDetails };
                        spinActions.style.display = 'flex';
                    } else {
                        spinnerResultText.textContent = 'å‡ºéŒ¯äº†ï¼Œè«‹åˆ·æ–°é é¢ï¼';
                        spinActions.style.display = 'none';
                    }
                }, 5000);
            };

            function handleMouseMove(e) {
                if (isSpinning) return;

                const rect = wheel.getBoundingClientRect();
                const scaleX = wheel.width / rect.width;
                const scaleY = wheel.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                const centerX = wheel.width / 2;
                const centerY = wheel.height / 2;
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const baseRadius = wheel.width / 2 - 10;
                const oldHoveredIndex = hoveredSliceIndex;
                let newHoveredIndex = null;

                if (distance <= baseRadius + 5) {
                    const numOptions = spinnerOptions.length;
                    if (numOptions > 0) {
                        // This is the robust, corrected calculation
                        const mouseAngleRad = Math.atan2(dy, dx);
                        const rotationRad = (currentRotation % 360) * Math.PI / 180;
                        const unrotatedAngleRad = mouseAngleRad - rotationRad;
                        
                        // Adjust for our drawing start at -PI/2 (the top)
                        const angleRelativeToTop = unrotatedAngleRad + Math.PI / 2;
                        
                        // Normalize to a 0 to 2*PI range
                        let normalizedAngle = angleRelativeToTop % (2 * Math.PI);
                        if (normalizedAngle < 0) {
                            normalizedAngle += (2 * Math.PI);
                        }
                        
                        const arcSizeRad = 2 * Math.PI / numOptions;
                        newHoveredIndex = Math.floor(normalizedAngle / arcSizeRad);
                    }
                }

                if (newHoveredIndex !== oldHoveredIndex) {
                    hoveredSliceIndex = newHoveredIndex;
                    drawWheel();
                    if (newHoveredIndex !== null) {
                        spinnerResultText.textContent = 'é»æ“ŠæŒ‰éˆ•ä¾†æ±ºå®šä½ çš„ä¸‹ä¸€é¤ï¼';
                    } else if (!isSpinning && spinActions.style.display === 'none') {
                        spinnerResultText.textContent = 'å°‡æ»‘é¼ ç§»åˆ°è½‰ç›¤ä¸Šçœ‹çœ‹æœ‰ä»€éº¼å¥½æ–™ï¼';
                    }
                }
            }

            function handleMouseLeave(e) {
                if (isSpinning) return;
                if (hoveredSliceIndex !== null) {
                    hoveredSliceIndex = null;
                    drawWheel();
                    if (!isSpinning && spinActions.style.display === 'none') {
                        spinnerResultText.textContent = 'å°‡æ»‘é¼ ç§»åˆ°è½‰ç›¤ä¸Šçœ‹çœ‹æœ‰ä»€éº¼å¥½æ–™ï¼';
                    }
                }
            }

            // --- History Log ---
            const formatTimestamp = (ts) => new Date(ts).toLocaleString('zh-TW', { dateStyle: 'short', timeStyle: 'short' });

            const renderHistory = () => {
                historySection.style.display = history.length > 0 ? 'block' : 'none';
                historyList.innerHTML = '';
                history.slice().reverse().forEach((entry, revIndex) => {
                    const originalIndex = history.length - 1 - revIndex;
                    const li = document.createElement('li');
                    const imgHTML = entry.image ? `<img src="${entry.image}" class="history-img" alt="${entry.text}">` : `<div class="history-img">ç„¡åœ–ç‰‡</div>`;
                    const noteHTML = entry.note ? `<p>${entry.note}</p>` : '';
                    li.innerHTML = `
                        ${imgHTML}
                        <div class="history-details">
                            <div class="history-header">
                                <h4>${entry.text}</h4>
                                <div class="history-actions">
                                    <button class="edit-btn" title="ç·¨è¼¯" style="background:none; border:none; cursor:pointer; color: var(--text-secondary-color); font-size: 1em; opacity: 0.7;">âœï¸</button>
                                    <button class="delete-btn" title="åˆªé™¤" style="background:none; border:none; cursor:pointer; color: var(--text-secondary-color); font-size: 1em; opacity: 0.7;">ğŸ—‘ï¸</button>
                                </div>
                            </div>
                            ${noteHTML}
                            <span class="timestamp">${formatTimestamp(entry.timestamp)}</span>
                        </div>
                    `;
                    li.querySelector('.edit-btn').addEventListener('click', () => {
                        showLogModal({ index: originalIndex, entry: history[originalIndex], title: `ç·¨è¼¯æ—¥èªŒ - ${history[originalIndex].text}`, saveText: 'å„²å­˜è®Šæ›´', cancelText: 'å–æ¶ˆ' });
                    });
                    li.querySelector('.delete-btn').addEventListener('click', () => deleteHistoryEntry(originalIndex));
                    historyList.appendChild(li);
                });
            };

            const saveHistory = (entry) => {
                if (editingIndex !== null) {
                    history[editingIndex] = { ...history[editingIndex], ...entry };
                } else {
                    entry.timestamp = Date.now();
                    history.push(entry);
                }
                localStorage.setItem('foodWheelHistory', JSON.stringify(history));
                renderHistory();
            };
            
            const deleteHistoryEntry = (index) => {
                if (confirm(`ç¢ºå®šè¦åˆªé™¤é€™ç­†ã€Œ${history[index].text}ã€çš„æ—¥èªŒå—ï¼Ÿ`)) {
                    history.splice(index, 1);
                    localStorage.setItem('foodWheelHistory', JSON.stringify(history));
                    renderHistory();
                }
            };
            
            const loadHistory = () => {
                const savedHistory = localStorage.getItem('foodWheelHistory');
                if (savedHistory) history = JSON.parse(savedHistory);
                renderHistory();
            };

            const clearHistory = () => {
                if (history.length > 0 && confirm('ç¢ºå®šè¦æ¸…é™¤ã€æ‰€æœ‰ã€‘ç¾é£Ÿæ—¥èªŒç´€éŒ„å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚')) {
                    history = [];
                    localStorage.removeItem('foodWheelHistory');
                    renderHistory();
                }
            };

            // --- Log Modal Functions ---
            const showLogModal = (config) => {
                editingIndex = typeof config.index === 'number' ? config.index : null;
                currentLogEntry = { ...config.entry };
                modalTitle.textContent = config.title;
                modalImagePreview.innerHTML = currentLogEntry.image ? `<img src="${currentLogEntry.image}" alt="é è¦½">` : '<span>åœ–ç‰‡é è¦½å€</span>';
                modalTextInput.value = currentLogEntry.note || '';
                modalImageInput.value = '';
                modalSaveBtn.textContent = config.saveText;
                modalCancelBtn.textContent = config.cancelText;
                modalOverlay.style.display = 'flex';
            };
            const hideLogModal = () => modalOverlay.style.display = 'none';

            const handleImageUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                try {
                    currentLogEntry.image = await resizeImage(file, 800, 800, 0.8);
                    modalImagePreview.innerHTML = `<img src="${currentLogEntry.image}" alt="é è¦½">`;
                } catch (error) { console.error("åœ–ç‰‡è™•ç†å¤±æ•—:", error); alert("åœ–ç‰‡è™•ç†å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚"); }
            };
            
            const handleSaveLog = () => {
                currentLogEntry.note = modalTextInput.value.trim();
                saveHistory(currentLogEntry);
                hideLogModal();
            };

            // --- Custom Preferences ---
            function renderCustomPrefs() {
                customPrefsDisplay.innerHTML = '';
                customPreferences.forEach((pref, index) => {
                    const tag = document.createElement('span');
                    tag.className = 'custom-tag';
                    tag.textContent = pref;
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-tag-btn';
                    deleteBtn.textContent = 'x';
                    deleteBtn.onclick = () => { customPreferences.splice(index, 1); renderCustomPrefs(); savePrefsToLocalStorage(); };
                    tag.appendChild(deleteBtn);
                    customPrefsDisplay.appendChild(tag);
                });
            }
            function savePrefsToLocalStorage() { localStorage.setItem('myMenuAppCustomPrefs', JSON.stringify(customPreferences)); }
            function loadPrefsFromLocalStorage() { const savedPrefs = localStorage.getItem('myMenuAppCustomPrefs'); if (savedPrefs) { customPreferences = JSON.parse(savedPrefs); renderCustomPrefs(); } }

            // --- Main Process Flow ---
            let finalTranslationMap = {};
            processBtn.addEventListener('click', async () => {
                let imageSource = (imageInput.files && imageInput.files.length > 0) ? imageInput.files[0] : imagePreview.src;
                if (!imageSource) { alert('æ²’æœ‰æ‰¾åˆ°å¯åˆ†æçš„åœ–ç‰‡ï¼'); return; }
                processBtn.disabled = true;
                analysisResultsSection.style.display = 'block';

                try {
                    const ocrText = await getOcrText(imageSource);
                    if (!ocrText) { updateStatus('éŒ¯èª¤ï¼šç„¡æ³•å¾åœ–ç‰‡ä¸­è¾¨è­˜æ–‡å­—ã€‚', false); return; }
                    
                    updateStatus('OCR è¾¨è­˜å®Œæˆï¼Œæ­£åœ¨è«‹ AI è¾¨è­˜èœå“åç¨±...', true);
                    const originalDishes = await filterDishesWithAzureAI(ocrText);
                    if (originalDishes.length === 0) {
                        updateStatus('AI åœ¨åœ–ç‰‡ä¸­æ²’æœ‰æ‰¾åˆ°å¯è¾¨è­˜çš„èœå“é …ç›®ã€‚', false);
                        spinnerSection.style.display = 'none';
                        return;
                    }

                    updateStatus(`èœå“è¾¨è­˜å®Œæˆ (${originalDishes.length}é …)ï¼Œæ­£åœ¨ç‚ºæ¯å€‹èœå“é€²è¡Œæ™ºæ…§åˆ†æ...`, true);
                    allAnalyzedDishes = await analyzeIngredientsWithAzureAI(originalDishes, customPreferences);
                    
                    recommendedDishes = [];
                    const dishesWithReasons = allAnalyzedDishes.map(dish => {
                        const filterReason = getFilterReasons(dish);
                        return { ...dish, filterReason: filterReason };
                    });
                    dishesWithReasons.forEach(dish => { if (!dish.filterReason) { recommendedDishes.push(dish); } });

                    const targetLang = languageSelector.value;
                    const allTextsToTranslate = new Set();
                    dishesWithReasons.forEach(dish => {
                        if(dish.error) return;
                        allTextsToTranslate.add(dish.englishName);
                        allTextsToTranslate.add(dish.mainIngredients.join(', '));
                        if (dish.filterReason) allTextsToTranslate.add(dish.filterReason);
                    });
                    finalTranslationMap = await translateText(Array.from(allTextsToTranslate), 'en', targetLang);
                    const finalHtml = generateFinalHtml(dishesWithReasons, finalTranslationMap);
                    resultsDiv.innerHTML = finalHtml;

                    spinnerOptions = recommendedDishes.map(dish => {
                        return targetLang === 'en' ? dish.englishName : (finalTranslationMap[dish.englishName] || dish.englishName);
                    });

                    spinnerSection.style.display = 'block';
                    spinnerResultText.textContent = spinnerOptions.length > 0 ? 'å°‡æ»‘é¼ ç§»åˆ°è½‰ç›¤ä¸Šçœ‹çœ‹æœ‰ä»€éº¼å¥½æ–™ï¼' : 'æ²’æœ‰æ¨è–¦èœè‰²å¯ä¾›é¸æ“‡ã€‚';
                    drawWheel();
                    
                } catch (error) {
                    console.error('ç™¼ç”ŸéŒ¯èª¤:', error);
                    updateStatus(`ç™¼ç”ŸéŒ¯èª¤: ${error.message}`, false);
                    spinnerSection.style.display = 'none';
                } finally {
                    processBtn.disabled = false;
                }
            });

            // --- Event Listeners ---
            imageInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => { imagePreview.src = e.target.result; };
                    reader.readAsDataURL(file);
                }
            });
            addPrefBtn.addEventListener('click', () => {
                const newPref = customPrefInput.value.trim();
                if (newPref && !customPreferences.includes(newPref)) {
                    customPreferences.push(newPref);
                    customPrefInput.value = '';
                    renderCustomPrefs();
                    savePrefsToLocalStorage();
                }
            });
            customPrefInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addPrefBtn.click(); });
            spinBtn.addEventListener('click', spin);
            keepBtn.addEventListener('click', () => {
                showLogModal({ entry: currentLogEntry, title: `è¨˜éŒ„ç¾é£Ÿ - ${currentLogEntry.text}`, saveText: 'å„²å­˜æ—¥èªŒ', cancelText: 'ç•¥é' });
                spinActions.style.display = 'none';
                spinnerResultText.textContent = `å¤ªæ£’äº†ï¼å°±æ±ºå®šåƒã€Œ${currentLogEntry.text}ã€`;
            });
            respinBtn.addEventListener('click', () => {
                spinActions.style.display = 'none';
                spinnerResultText.textContent = 'é‡æ–°é¸æ“‡ä¸­...';
                spin();
            });
            clearHistoryBtn.addEventListener('click', clearHistory);
            modalImageInput.addEventListener('change', handleImageUpload);
            modalSaveBtn.addEventListener('click', handleSaveLog);
            modalCancelBtn.addEventListener('click', hideLogModal);
            modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) hideLogModal(); });
            wheel.addEventListener('mousemove', handleMouseMove);
            wheel.addEventListener('mouseleave', handleMouseLeave);

            // --- Initial Load ---
            loadPrefsFromLocalStorage();
            loadHistory();
            drawWheel();
        });
    </script>
</body>
</html>